// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.1
// source: src/Model/serializable.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum GadgetType {
  Suisei = 0,
  UNRECOGNIZED = -1,
}

export function gadgetTypeFromJSON(object: any): GadgetType {
  switch (object) {
    case 0:
    case "Suisei":
      return GadgetType.Suisei;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GadgetType.UNRECOGNIZED;
  }
}

export function gadgetTypeToJSON(object: GadgetType): string {
  switch (object) {
    case GadgetType.Suisei:
      return "Suisei";
    case GadgetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectionType {
  OpticFiber = 0,
  Satellite = 1,
  UNRECOGNIZED = -1,
}

export function connectionTypeFromJSON(object: any): ConnectionType {
  switch (object) {
    case 0:
    case "OpticFiber":
      return ConnectionType.OpticFiber;
    case 1:
    case "Satellite":
      return ConnectionType.Satellite;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionType.UNRECOGNIZED;
  }
}

export function connectionTypeToJSON(object: ConnectionType): string {
  switch (object) {
    case ConnectionType.OpticFiber:
      return "OpticFiber";
    case ConnectionType.Satellite:
      return "Satellite";
    case ConnectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EntityCoordinates {
  x: number;
  y: number;
}

export interface Router {
  hostname: string;
  lanIpAddr: string;
  extIpAddr: string;
  coords: EntityCoordinates | undefined;
}

export interface Endpoint {
  hostname: string;
  ipAddr: string;
  coords: EntityCoordinates | undefined;
}

export interface Gadget {
  name: string;
  type: GadgetType;
  coords: EntityCoordinates | undefined;
}

export interface Connection {
  name: string;
  from: string;
  to: string;
  weight: number;
  duplex: boolean;
  errors: number;
  highlighted: boolean;
  type: ConnectionType;
}

export interface ModelSnapshot {
  endpoints: Endpoint[];
  routers: Router[];
  gadgets: Gadget[];
  connections: Connection[];
}

function createBaseEntityCoordinates(): EntityCoordinates {
  return { x: 0, y: 0 };
}

export const EntityCoordinates: MessageFns<EntityCoordinates> = {
  encode(message: EntityCoordinates, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).sfixed32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).sfixed32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityCoordinates {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityCoordinates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.sfixed32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.sfixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityCoordinates {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: EntityCoordinates): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EntityCoordinates>, I>>(base?: I): EntityCoordinates {
    return EntityCoordinates.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EntityCoordinates>, I>>(object: I): EntityCoordinates {
    const message = createBaseEntityCoordinates();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseRouter(): Router {
  return { hostname: "", lanIpAddr: "", extIpAddr: "", coords: undefined };
}

export const Router: MessageFns<Router> = {
  encode(message: Router, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.lanIpAddr !== "") {
      writer.uint32(18).string(message.lanIpAddr);
    }
    if (message.extIpAddr !== "") {
      writer.uint32(26).string(message.extIpAddr);
    }
    if (message.coords !== undefined) {
      EntityCoordinates.encode(message.coords, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Router {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lanIpAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.extIpAddr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.coords = EntityCoordinates.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Router {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      lanIpAddr: isSet(object.lanIpAddr) ? globalThis.String(object.lanIpAddr) : "",
      extIpAddr: isSet(object.extIpAddr) ? globalThis.String(object.extIpAddr) : "",
      coords: isSet(object.coords) ? EntityCoordinates.fromJSON(object.coords) : undefined,
    };
  },

  toJSON(message: Router): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.lanIpAddr !== "") {
      obj.lanIpAddr = message.lanIpAddr;
    }
    if (message.extIpAddr !== "") {
      obj.extIpAddr = message.extIpAddr;
    }
    if (message.coords !== undefined) {
      obj.coords = EntityCoordinates.toJSON(message.coords);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Router>, I>>(base?: I): Router {
    return Router.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Router>, I>>(object: I): Router {
    const message = createBaseRouter();
    message.hostname = object.hostname ?? "";
    message.lanIpAddr = object.lanIpAddr ?? "";
    message.extIpAddr = object.extIpAddr ?? "";
    message.coords = (object.coords !== undefined && object.coords !== null)
      ? EntityCoordinates.fromPartial(object.coords)
      : undefined;
    return message;
  },
};

function createBaseEndpoint(): Endpoint {
  return { hostname: "", ipAddr: "", coords: undefined };
}

export const Endpoint: MessageFns<Endpoint> = {
  encode(message: Endpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.ipAddr !== "") {
      writer.uint32(18).string(message.ipAddr);
    }
    if (message.coords !== undefined) {
      EntityCoordinates.encode(message.coords, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coords = EntityCoordinates.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      ipAddr: isSet(object.ipAddr) ? globalThis.String(object.ipAddr) : "",
      coords: isSet(object.coords) ? EntityCoordinates.fromJSON(object.coords) : undefined,
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.ipAddr !== "") {
      obj.ipAddr = message.ipAddr;
    }
    if (message.coords !== undefined) {
      obj.coords = EntityCoordinates.toJSON(message.coords);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.hostname = object.hostname ?? "";
    message.ipAddr = object.ipAddr ?? "";
    message.coords = (object.coords !== undefined && object.coords !== null)
      ? EntityCoordinates.fromPartial(object.coords)
      : undefined;
    return message;
  },
};

function createBaseGadget(): Gadget {
  return { name: "", type: 0, coords: undefined };
}

export const Gadget: MessageFns<Gadget> = {
  encode(message: Gadget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.coords !== undefined) {
      EntityCoordinates.encode(message.coords, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gadget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGadget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coords = EntityCoordinates.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gadget {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? gadgetTypeFromJSON(object.type) : 0,
      coords: isSet(object.coords) ? EntityCoordinates.fromJSON(object.coords) : undefined,
    };
  },

  toJSON(message: Gadget): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = gadgetTypeToJSON(message.type);
    }
    if (message.coords !== undefined) {
      obj.coords = EntityCoordinates.toJSON(message.coords);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gadget>, I>>(base?: I): Gadget {
    return Gadget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gadget>, I>>(object: I): Gadget {
    const message = createBaseGadget();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.coords = (object.coords !== undefined && object.coords !== null)
      ? EntityCoordinates.fromPartial(object.coords)
      : undefined;
    return message;
  },
};

function createBaseConnection(): Connection {
  return { name: "", from: "", to: "", weight: 0, duplex: false, errors: 0, highlighted: false, type: 0 };
}

export const Connection: MessageFns<Connection> = {
  encode(message: Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.weight !== 0) {
      writer.uint32(32).uint32(message.weight);
    }
    if (message.duplex !== false) {
      writer.uint32(40).bool(message.duplex);
    }
    if (message.errors !== 0) {
      writer.uint32(48).uint32(message.errors);
    }
    if (message.highlighted !== false) {
      writer.uint32(56).bool(message.highlighted);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duplex = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.errors = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.highlighted = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      duplex: isSet(object.duplex) ? globalThis.Boolean(object.duplex) : false,
      errors: isSet(object.errors) ? globalThis.Number(object.errors) : 0,
      highlighted: isSet(object.highlighted) ? globalThis.Boolean(object.highlighted) : false,
      type: isSet(object.type) ? connectionTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Connection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.duplex !== false) {
      obj.duplex = message.duplex;
    }
    if (message.errors !== 0) {
      obj.errors = Math.round(message.errors);
    }
    if (message.highlighted !== false) {
      obj.highlighted = message.highlighted;
    }
    if (message.type !== 0) {
      obj.type = connectionTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Connection>, I>>(base?: I): Connection {
    return Connection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Connection>, I>>(object: I): Connection {
    const message = createBaseConnection();
    message.name = object.name ?? "";
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.weight = object.weight ?? 0;
    message.duplex = object.duplex ?? false;
    message.errors = object.errors ?? 0;
    message.highlighted = object.highlighted ?? false;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseModelSnapshot(): ModelSnapshot {
  return { endpoints: [], routers: [], gadgets: [], connections: [] };
}

export const ModelSnapshot: MessageFns<ModelSnapshot> = {
  encode(message: ModelSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.endpoints) {
      Endpoint.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.routers) {
      Router.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.gadgets) {
      Gadget.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoints.push(Endpoint.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.routers.push(Router.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gadgets.push(Gadget.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelSnapshot {
    return {
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => Endpoint.fromJSON(e))
        : [],
      routers: globalThis.Array.isArray(object?.routers) ? object.routers.map((e: any) => Router.fromJSON(e)) : [],
      gadgets: globalThis.Array.isArray(object?.gadgets) ? object.gadgets.map((e: any) => Gadget.fromJSON(e)) : [],
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModelSnapshot): unknown {
    const obj: any = {};
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints.map((e) => Endpoint.toJSON(e));
    }
    if (message.routers?.length) {
      obj.routers = message.routers.map((e) => Router.toJSON(e));
    }
    if (message.gadgets?.length) {
      obj.gadgets = message.gadgets.map((e) => Gadget.toJSON(e));
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelSnapshot>, I>>(base?: I): ModelSnapshot {
    return ModelSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelSnapshot>, I>>(object: I): ModelSnapshot {
    const message = createBaseModelSnapshot();
    message.endpoints = object.endpoints?.map((e) => Endpoint.fromPartial(e)) || [];
    message.routers = object.routers?.map((e) => Router.fromPartial(e)) || [];
    message.gadgets = object.gadgets?.map((e) => Gadget.fromPartial(e)) || [];
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
